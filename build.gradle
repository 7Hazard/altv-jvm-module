import org.gradle.internal.os.OperatingSystem;

buildscript {
	repositories {
		mavenLocal()
		mavenCentral()
		jcenter()
	}
}

plugins {
	id "java"
	id "eclipse"
	id 'java-library-distribution'
	
	// Publishing
	// id "com.jfrog.bintray" version "1.7.3"
	id "maven"
}

repositories {
	// maven { url "https://jitpack.io" }
	mavenLocal()
	mavenCentral()
	jcenter()
}

group = 'com.gitlab.7Hazard'

sourceSets {
	main {
		java {
			srcDirs = ['src']
		}
	}
}

dependencies {
	// https://mvnrepository.com/artifact/com.github.jnr/jnr-ffi
	compile group: 'com.github.jnr', name: 'jnr-ffi', version: '2.1.9'
}

tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:all" << "-Xlint:-rawtypes" << "-Werror"
}

jar {
	manifest {
		attributes(
			'Main-Class': 'alt.v.jvm.Main',
		)
	}
	from {
		configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
	}
}

if(System.env['JITPACK'] == null)
{
	task wrap(type: Exec) {
		standardOutput = out
		commandLine "node", "wrap"
		dependsOn "buildModule"
	}
	compileJava.dependsOn wrap
}

project.ext.set("debug", false)
task debug() {
	project.debug = true
}

// task called before build for preparing build
task prep

def downloadFile(url, dest)
{
	def f = new File(dest)
	if (!f.exists()) {
			new URL(url).withInputStream{ i -> f.withOutputStream{ it << i }}
	}
}

task getCAPI(type: Copy) {
	mkdir "build/altv-capi/server"

	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/capi/server/altv-capi.json", "build/altv-capi/altv-capi-server.json")
	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/capi/altv-capi-server.h", "build/altv-capi/altv-capi-server.h")
	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/capi/altv-capi-predefines.h", "build/altv-capi/altv-capi-predefines.h")
	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/capi/altv-capi-extra.h", "build/altv-capi/altv-capi-extra.h")
	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/capi/server/altv-capi.h", "build/altv-capi/server/altv-capi.h")
	downloadFile("https://cdn.altv.mp/server/hazard-dev1/x64_win32/altv-server.lib", "build/altv-capi/altv-server.lib")
}
prep.dependsOn getCAPI

if(System.env['JITPACK'] == null)
{
	task buildModule(type: Exec) {
		standardOutput = out
		workingDir "module"

    def version = "${System.env['CI_PIPELINE_IID']}-${System.env['CI_COMMIT_REF_SLUG']}"
    
    if(project.debug)
    {
      if(OperatingSystem.current().isWindows())
        commandLine "cmd", "/c", "build-debug.bat", version // windows
      else
        commandLine "./build-debug.sh", version // linux/mac
    }
    else
    {
      if(OperatingSystem.current().isWindows())
        commandLine "cmd", "/c", "build.bat", version // windows
      else
        commandLine "./build.sh", version // linux/mac
    }

		//store the output instead of printing to the console:
		standardOutput = new ByteArrayOutputStream()

		//extension method stopTomcat.output() can be used to obtain the output:
		ext.output = {
			return standardOutput.toString()
		}
	}
	buildModule.dependsOn getCAPI
	prep.dependsOn buildModule
}

// task cleanBuild() {
//     new File("${buildDir}").delete()
// }
// clean.dependsOn cleanBuild

task copyToOutput(type: Copy) {
	from jar.destinationDir
	into "build/altv-jvm-module"

	//from configurations.runtime
	//into "build/altv-jvm-module"

	outputs.upToDateWhen { false }
}
jar.finalizedBy copyToOutput

distributions {
	main {
		baseName = 'altv-jvm-module'
		contents {
			if(System.env['JITPACK'] == null)
			{    
				from "module/build/libs/module/shared/altv-jvm-module.dll"
			}
		}
	}
}



///
/// Publishing
///

if(System.env['JITPACK'] != null)
{
	println "JITPACK BUILD"
}

task sourcesJar(type: Jar, dependsOn: classes) {
	classifier = 'sources'
	from sourceSets.main.allJava
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	classifier = 'javadoc'
	javadoc.failOnError(false);
	javadoc.source = sourceSets.main.allJava
	from javadoc.destinationDir
}

artifacts {
	archives sourcesJar
	archives javadocJar
}
