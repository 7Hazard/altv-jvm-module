
task wrapCAPI {
    def capiBuff = "" << new File('./altv-capi/include/altv/capi.h').getText('UTF-8')

    def includeCache = []
    // Recursive include handler
    while (capiBuff.contains("#include \""))
    {
        // Get the #include line and include path
        def incBegin = capiBuff.indexOf("#include \"")
        def incEnd = capiBuff.indexOf("\"", incBegin+10)+1
        def incStr = capiBuff.substring(incBegin, incEnd)
        def incPath = incStr.substring(incStr.indexOf("\"")+1, incStr.length()-1)

        // Skip include if already included
        if(includeCache.contains(incPath)) {
            // Remove include
            capiBuff.replace(incBegin, incEnd, "")
            continue
        }
        includeCache.add(incPath)

        // Replace #include with the contents of the included file
        def incContent = new File('./altv-capi/include/altv/'+incPath).getText('UTF-8')
        capiBuff.replace(incBegin, incEnd, incContent)
    }

    // Remove CAPI macro defines
    capiBuff = new StringBuffer(capiBuff.toString().replaceAll("#.*.CAPI.*", ""))

    // Prepare the java capi buffers
    def jcapiTypes = "" << ""
    def jcapiFuncs = "" << ""

    def getStructType = { type ->
        switch(type) {
            case "int":  return "jnr.ffi.Struct.int32_t"
            case "long":  return "jnr.ffi.Struct.int64_t"
            case "float":  return "jnr.ffi.Struct.Float"
            case "double":  return "jnr.ffi.Struct.Double"
            case "bool":  return "jnr.ffi.Struct.Boolean"
            case "int8_t":  return "jnr.ffi.Struct.int8_t"
            case "uint8_t":  return "jnr.ffi.Struct.u_int8_t"
            case "int16_t":  return "jnr.ffi.Struct.int16_t"
            case "uint16_t":  return "jnr.ffi.Struct.u_int16_t"
            case "int32_t":  return "jnr.ffi.Struct.int32_t"
            case "uint32_t":  return "jnr.ffi.Struct.u_int32_t"
            case "int64_t":  return "jnr.ffi.Struct.int64_t"
            case "uint64_t":  return "jnr.ffi.Struct.u_int64_t"
            case "uintmax_t":  return "jnr.ffi.Struct.u_int64_t"
            case "const char *":  return "UTF8String"
        }
        if(type.endsWith("*")) return "jnr.ffi.Struct.Pointer"
        return type
    }

    def typesCache = [
        "void": "void",
        "int": "int",
        "long": "long",
        "float": "float",
        "double": "double",
        "bool": "boolean",
        "int8_t": "@jnr.ffi.types.int8_t byte",
        "uint8_t": "@jnr.ffi.types.u_int8_t byte",
        "int16_t": "@jnr.ffi.types.int16_t short",
        "uint16_t": "@jnr.ffi.types.u_int16_t short",
        "int32_t": "@jnr.ffi.types.int32_t int",
        "uint32_t": "@jnr.ffi.types.u_int32_t int",
        "int64_t": "@jnr.ffi.types.int64_t long",
        "uint64_t": "@jnr.ffi.types.u_int64_t long",
        "uintmax_t": "@jnr.ffi.types.u_int64_t long",
        "const char *": "@jnr.ffi.annotations.Encoding(\"UTF-8\") String",
        "const char **": "@jnr.ffi.annotations.Encoding(\"UTF-8\") String[]",
    ]
    def getJType 
    getJType = { type ->
        def jtype = typesCache[type]

        if (jtype != null) return jtype;

        if(type.endsWith('*')) {
            typesCache[type] = "jnr.ffi.Pointer"
            return "jnr.ffi.Pointer"
        }

        def typeOverrideBegin = capiBuff.indexOf("#define ${type}_DEF")
        if(typeOverrideBegin != -1) {
            def fieldsBegin = capiBuff.indexOf("/// FIELDS BEGIN", typeOverrideBegin)+16
            def fieldsEnd = capiBuff.indexOf("/// FIELDS END", fieldsBegin)
            def fields = capiBuff.substring(fieldsBegin, fieldsEnd)
                .trim()
                .replaceAll("    ", "")
                .split(";")
            def jfields = []
            jcapiTypes << """
    public static class ${type} extends jnr.ffi.Struct
    {"""
            fields.each{ field ->
                field = field.trim();
                def fieldTypeEnd = field.lastIndexOf(" ")
                def fieldType = field.substring(0, fieldTypeEnd)
                def fieldName = field.substring(fieldTypeEnd+1)

                jfields.add(getJType(fieldType)+" "+fieldName)

                def structType = getStructType(fieldType)
                jcapiTypes << """
        public final ${structType} ${fieldName} = new ${structType}();"""
                
            }
            def jfieldsStr = jfields.toString().replaceAll("\\[|\\]", "")
            jcapiTypes << """

        public ${type}(${jfieldsStr})
        {
            super(CAPI.runtime);
            """
            jfields.each{ field ->
                def fieldTypeEnd = field.lastIndexOf(" ")
                def fieldType = field.substring(0, fieldTypeEnd)
                def fieldName = field.substring(fieldTypeEnd+1)

                jcapiTypes << """
            this.${fieldName}.set(${fieldName});"""
            }

            jcapiTypes << """
        }

        public ${type}(jnr.ffi.Runtime runtime)
        {
            super(runtime);
        }
    }"""

            typesCache[type] = type;
            return type
        }

        def enumBegin = capiBuff.indexOf("typedef enum "+type)
        if(enumBegin != -1) {
            enumBegin = capiBuff.indexOf("    ", enumBegin)
            def enumEnd = capiBuff.indexOf("}", enumBegin)-1
            def enumValues = capiBuff.substring(enumBegin, enumEnd)
                .replaceAll("    ", "")
                .replaceAll("\n", "")
                .split(",")
                
            jcapiTypes << """
    public static enum ${type} implements jnr.ffi.util.EnumMapper.IntegerEnum
    {
        ${
            enumValues.toString()
            .replaceAll("\\[|\\]", "")
            .replaceAll(", ", "),\n        ")
            .replaceAll(" = ", "(") + ");"
        }
        
        ${type}(int value) {
            this.value = value;
        }
        
        public int intValue() {
            return value;
        }
        private final int value;
    }"""

            typesCache[type] = type;
            return type;
        }

        def cbBegin = capiBuff.indexOf("(*${type})")
        if(cbBegin != -1) {
            cbBegin = capiBuff.lastIndexOf("typedef", cbBegin)
            def cbEnd = capiBuff.indexOf(";", cbBegin)
            def cbStr = capiBuff.substring(cbBegin, cbEnd)

            def retBegin = cbStr.indexOf(" ")+1
            def retEnd = cbStr.indexOf(" ", retBegin)
            def ret = cbStr.substring(retBegin, retEnd)
            def jret = getJType(ret)

            def argsEnd = cbStr.length()-1
            def argsBegin = cbStr.lastIndexOf("(")+1
            def args = cbStr.substring(argsBegin, argsEnd).split(", ")
            
            def jargs = []
            if(args[0] != "void") {
                args.each{ arg ->
                    def argTypeEnd = arg.lastIndexOf(" ")
                    def argType = arg.substring(0, argTypeEnd)
                    def argName = arg.substring(argTypeEnd+1, arg.length())

                    def jarg = getJType(argType)
                    jargs.add(jarg+" "+argName)
                }
            }

            jcapiTypes << """
    public interface ${type}
    {
        @jnr.ffi.annotations.Delegate public ${jret} callback(${jargs.toString().replaceAll("\\[|\\]", "")});
    }"""
            
            typesCache[type] = type
            return type
        }

        // Just return the type
        return type
    }

    def getJFunc = { funcStr ->
        def cnameEnd = funcStr.indexOf('(')
        def cnameBegin = funcStr.lastIndexOf('alt_', cnameEnd)
        def cname = funcStr.substring(cnameBegin, cnameEnd)

        def cretBegin = 5
        def cretEnd = cnameBegin-1
        def cret = funcStr.substring(cretBegin, cretEnd)
        
        def jret = getJType(cret)

        def jparams = "" << ""
        def cparamsBegin = funcStr.indexOf("(")+1
        def cparamsEnd = funcStr.lastIndexOf(")")
        def cparams = funcStr.substring(cparamsBegin, cparamsEnd).split(", ")

        for (def i = 0; i < cparams.size(); i++) {
            def cparam = cparams[i]
            if (cparam == "") continue
            def paramTypeBegin = cparam.lastIndexOf(" ")
            def cparamType = cparam.substring(0, paramTypeBegin)
            def paramName = cparam.substring(paramTypeBegin+1)

            def jparamType = getJType(cparamType)
            jparams << jparamType << " " << paramName

            if(i!=cparams.size()-1) jparams << ", "
        }

        def jfunc = "${jret} ${cname}(${jparams});"

        jcapiFuncs << jfunc << "\n        "
    }

    // Process all functions
    while (capiBuff.contains("CAPI "))
    {
        // Get func decl
        def funcBegin = capiBuff.indexOf("CAPI ")
        def funcEnd = capiBuff.indexOf(";", funcBegin)+1
        def funcStr = capiBuff.substring(funcBegin, funcEnd)

        // Convert to Java
        getJFunc(funcStr)

        // Remove processed func decl
        capiBuff.replace(funcBegin, funcEnd, "")
    }

    // Final result
    def jcapi = new File("java/src/alt/v/jvm/CAPI.java")
    jcapi.write """
package alt.v.jvm;

public class CAPI
{
    public static final CAPIFunctions func = jnr.ffi.LibraryLoader.create(CAPIFunctions.class).load("altv-capi");
    static jnr.ffi.Runtime runtime = jnr.ffi.Runtime.getRuntime(func);

    ${jcapiTypes}

    public static interface CAPIFunctions
    {
        ${jcapiFuncs}
    }
}
"""
}
